name: hanaDbFlex
apis: 
  - database: hana
    db_conn: hdb://USERNAME:PASSWORD@HOSTNAME_OR_IP:PORT
    logging:
      open: true
    custom_attributes: # applies to all queries
      host: YOUR_HANA_HOSTNAME
    db_async: true # process queries async
    db_queries: 
      - name: disk_logical_ids
        run: SELECT m_disks.device_id AS DEVICE_ID, String_agg(m_disks.disk_id, ', ') AS DISK_IDS FROM sys.m_disks GROUP BY m_disks.device_id
      
      - name: disk_main_collect
        run: SELECT m_disks.device_id AS DEVICE_ID, Concat('Disk ', m_disks.device_id) AS DEVICE_NAME, m_disks.host AS HOST, Sum(total_sync_reads) + Sum(total_async_reads) AS TOTAL_READS, Sum(total_sync_writes) + Sum(total_async_writes) AS TOTAL_WRITES, Sum(total_read_size) AS TOTAL_READ_SIZE, Sum(total_write_size) AS TOTAL_WRITE_SIZE, m_disks.used_size AS USED_SIZE, m_disks.total_size AS TOTAL_SIZE, CAST(m_disks.used_size / m_disks.total_size * 100 AS INT) AS DISK_UTILIZATION FROM sys.m_disks LEFT OUTER JOIN sys.m_volume_sizes ON m_disks.disk_id = m_volume_sizes.disk_id LEFT OUTER JOIN sys.m_volumes ON m_volumes.volume_id = m_volume_sizes.volume_id LEFT OUTER JOIN sys.m_volume_io_statistics ON m_volumes.volume_id = m_volume_io_statistics.volume_id WHERE m_disks.device_id >= 0 GROUP BY m_disks.device_id, m_disks.host, m_disks.used_size, m_disks.total_size

      - name: volumes
        run: SELECT m_volumes.volume_id AS VOLUME_ID, m_volumes.host AS HOST, m_volumes.port AS PORT, m_volumes.service_name AS SERVICE_NAME, m_volumes.subpath AS SUBPATH, M_VOLUME_IO_STATISTICS.total_sync_reads + M_VOLUME_IO_STATISTICS.total_async_reads AS TOTAL_READS, M_VOLUME_IO_STATISTICS.total_sync_writes + M_VOLUME_IO_STATISTICS.total_async_writes AS TOTAL_WRITES, CASE WHEN M_VOLUME_IO_STATISTICS.open_call_count IS NULL THEN 0 ELSE M_VOLUME_IO_STATISTICS.open_call_count END AS OPEN_CALL_COUNT, CASE WHEN M_VOLUME_IO_STATISTICS.close_call_count IS NULL THEN 0 ELSE M_VOLUME_IO_STATISTICS.close_call_count END AS CLOSE_CALL_COUNT, CASE WHEN M_VOLUME_IO_STATISTICS.exists_call_count IS NULL THEN 0 ELSE M_VOLUME_IO_STATISTICS.exists_call_count END AS EXISTS_CALL_COUNT, CASE WHEN M_VOLUME_IO_STATISTICS.remove_call_count IS NULL THEN 0 ELSE M_VOLUME_IO_STATISTICS.remove_call_count END AS REMOVE_CALL_COUNT, CASE WHEN M_VOLUME_IO_STATISTICS.resize_call_count IS NULL THEN 0 ELSE M_VOLUME_IO_STATISTICS.resize_call_count END AS RESIZE_CALL_COUNT, CASE WHEN M_VOLUME_IO_STATISTICS.sync_call_count IS NULL THEN 0 ELSE M_VOLUME_IO_STATISTICS.sync_call_count END AS SYNC_CALL_COUNT, CASE WHEN M_VOLUME_IO_STATISTICS.getsize_call_count IS NULL THEN 0 ELSE M_VOLUME_IO_STATISTICS.getsize_call_count END AS GETSIZE_CALL_COUNT, CASE WHEN M_VOLUME_IO_STATISTICS.getmodificationtime_call_count IS NULL THEN 0 ELSE M_VOLUME_IO_STATISTICS.getmodificationtime_call_count END AS GETMODIFICATIONTIME_CALL_COUNT, CASE WHEN M_VOLUME_IO_STATISTICS.getdeviceid_call_count IS NULL THEN 0 ELSE M_VOLUME_IO_STATISTICS.getdeviceid_call_count END AS GETDEVICEID_CALL_COUNT, M_VOLUME_IO_STATISTICS.eof_reads AS EOF_READS, M_VOLUME_IO_STATISTICS.total_sync_reads AS TOTAL_SYNC_READS, M_VOLUME_IO_STATISTICS.total_async_reads AS TOTAL_ASYNC_READS, M_VOLUME_IO_STATISTICS.total_trigger_async_reads AS TOTAL_TRIGGER_ASYNC_READS, M_VOLUME_IO_STATISTICS.total_short_reads AS TOTAL_SHORT_READS, M_VOLUME_IO_STATISTICS.total_full_retry_reads AS TOTAL_FULL_RETRY_READS, M_VOLUME_IO_STATISTICS.total_failed_reads AS TOTAL_FAILED_READS, M_VOLUME_IO_STATISTICS.total_read_size AS TOTAL_READ_SIZE, M_VOLUME_IO_STATISTICS.total_read_time AS TOTAL_READ_TIME, M_VOLUME_IO_STATISTICS.total_appends AS TOTAL_APPENDS, M_VOLUME_IO_STATISTICS.total_sync_writes AS TOTAL_SYNC_WRITES, M_VOLUME_IO_STATISTICS.total_async_writes AS TOTAL_ASYNC_WRITES, M_VOLUME_IO_STATISTICS.total_trigger_async_writes AS TOTAL_TRIGGER_ASYNC_WRITES, M_VOLUME_IO_STATISTICS.total_short_writes AS TOTAL_SHORT_WRITES, M_VOLUME_IO_STATISTICS.total_full_retry_writes AS TOTAL_FULL_RETRY_WRITES, M_VOLUME_IO_STATISTICS.total_failed_writes AS TOTAL_FAILED_WRITES, M_VOLUME_IO_STATISTICS.total_write_size AS TOTAL_WRITE_SIZE, M_VOLUME_IO_STATISTICS.total_write_time AS TOTAL_WRITE_TIME, M_VOLUME_IO_STATISTICS.total_io_time AS TOTAL_IO_TIME, M_VOLUME_SIZES.disk_ids AS DISK_IDS, M_VOLUME_SIZES.data_size AS DATA_SIZE, M_VOLUME_SIZES.log_size AS LOG_SIZE FROM sys.m_volumes INNER JOIN (SELECT volume_id, Sum(CASE WHEN data_size = -1 THEN 0 ELSE data_size END) AS DATA_SIZE, Sum(CASE WHEN log_size = -1 THEN 0 ELSE log_size END) AS LOG_SIZE, String_agg(disk_id, ', ') AS DISK_IDS FROM sys.m_volume_sizes GROUP BY volume_id) M_VOLUME_SIZES ON m_volumes.volume_id = M_VOLUME_SIZES.volume_id INNER JOIN (SELECT volume_id, Sum(open_call_count) AS OPEN_CALL_COUNT, Sum(close_call_count) AS CLOSE_CALL_COUNT, Sum(exists_call_count) AS EXISTS_CALL_COUNT, Sum(remove_call_count) AS REMOVE_CALL_COUNT, Sum(resize_call_count) AS RESIZE_CALL_COUNT, Sum(sync_call_count) AS SYNC_CALL_COUNT, Sum(getsize_call_count) AS GETSIZE_CALL_COUNT, Sum(getmodificationtime_call_count) AS GETMODIFICATIONTIME_CALL_COUNT, Sum(getdeviceid_call_count) AS GETDEVICEID_CALL_COUNT, Sum(enqueued_write_requests) AS ENQUEUED_WRITE_REQUESTS, Sum(blocked_write_requests) AS BLOCKED_WRITE_REQUESTS, Sum(eof_reads) AS EOF_READS, Sum(total_sync_reads) AS TOTAL_SYNC_READS, Sum(total_async_reads) AS TOTAL_ASYNC_READS, Sum(total_trigger_async_reads) AS TOTAL_TRIGGER_ASYNC_READS, Sum(total_short_reads) AS TOTAL_SHORT_READS, Sum(total_full_retry_reads) AS TOTAL_FULL_RETRY_READS, Sum(total_failed_reads) AS TOTAL_FAILED_READS, Sum(total_read_size) AS TOTAL_READ_SIZE, Sum(total_read_time) AS TOTAL_READ_TIME, Sum(total_appends) AS TOTAL_APPENDS, Sum(total_sync_writes) AS TOTAL_SYNC_WRITES, Sum(total_async_writes) AS TOTAL_ASYNC_WRITES, Sum(total_trigger_async_writes) AS TOTAL_TRIGGER_ASYNC_WRITES, Sum(total_short_writes) AS TOTAL_SHORT_WRITES, Sum(total_full_retry_writes) AS TOTAL_FULL_RETRY_WRITES, Sum(total_failed_writes) AS TOTAL_FAILED_WRITES, Sum(total_write_size) AS TOTAL_WRITE_SIZE, Sum(total_write_time) AS TOTAL_WRITE_TIME, Sum(total_io_time) AS TOTAL_IO_TIME FROM sys.m_volume_io_statistics GROUP BY volume_id) M_VOLUME_IO_STATISTICS ON m_volumes.volume_id = M_VOLUME_IO_STATISTICS.volume_id

      - name: service_shared_memory
        run: SELECT host, port, category, allocated_size, used_size, free_size FROM sys.m_shared_memory

      - name: host_connection_statistics_collect
        run: SELECT Sum(sent_message_size) AS TOTAL_DATA_SENT, Sum(received_message_size) AS TOTAL_DATA_RECEIVED, Sum(received_message_size) + Sum(sent_message_size) AS TOTAL_DATA_TRANFERRED, Sum(select_execution_count) AS TOTAL_SELECT_EXECUTIONS, Sum(update_count) AS TOTAL_UPDATE_EXECUTIONS, Count(m_connections.connection_id) AS CONNECTIONS, m_connections.host AS HOST FROM sys.m_connections INNER JOIN m_connection_statistics ON m_connections.connection_id = m_connection_statistics.connection_id WHERE m_connections.end_time IS NULL GROUP BY m_connections.host

      - name: host_service_statistics_collect
        run: SELECT Sum(requests_per_sec) AS REQUEST_RATE, Sum(requests_per_sec * response_time) / Sum(requests_per_sec) AS AVERAGE_RESPONSE_TIME, host FROM sys.m_service_statistics WHERE requests_per_sec >= 0 GROUP BY host

      - name: host_main_collect
        run: SELECT m_landscape_host_configuration.host AS HOST, host_active, host_status, CASE WHEN failover_status = '' THEN 'No failover pending or active' ELSE failover_status END AS FAILOVER_STATUS, failover_group, nameserver_config_role, nameserver_actual_role, indexserver_config_role, indexserver_actual_role, storage_partition, IP_ADDRESS.value AS IP_ADDRESSES, total_cpu_user_time + total_cpu_system_time + total_cpu_wio_time AS USED_CPU, total_cpu_user_time + total_cpu_system_time + total_cpu_wio_time + total_cpu_idle_time AS TOTAL_CPU, instance_total_memory_used_size AS DATABASE_MEMORY_USED, allocation_limit, used_physical_memory + shared_memory_allocated_size AS TOTAL_RESIDENT_MEMORY, physical_memory_size AS DATABASE_RESIDENT_MEMORY, used_physical_memory, used_physical_memory / ( used_physical_memory + free_physical_memory ) * 100 AS PHYSICAL_MEMORY_UTILIZATION, instance_total_memory_used_size / ( used_physical_memory + free_physical_memory ) * 100 AS DATABASE_MEMORY_UTILIZATION, process_cpu_time AS DATABASE_CPU_TIME, used_physical_memory + free_physical_memory AS TOTAL_PHYSICAL_MEMORY, used_swap_space, used_swap_space + free_swap_space AS TOTAL_SWAP_SPACE, used_swap_space / ( used_swap_space + free_swap_space ) * 100 AS SWAP_SPACE_UTILIZATION, CASE WHEN ACTIVE_THREADS.count IS NULL THEN 0 ELSE ACTIVE_THREADS.count END AS ACTIVE_THREAD_COUNT, CASE WHEN INACTIVE_THREADS.count IS NULL THEN 0 ELSE INACTIVE_THREADS.count END AS INACTIVE_THREAD_COUNT, CASE WHEN RUNNING_CONNECTIONS.count IS NULL THEN 0 ELSE RUNNING_CONNECTIONS.count END AS RUNNING_CONNECTION_COUNT, CASE WHEN IDLE_CONNECTIONS.count IS NULL THEN 0 ELSE IDLE_CONNECTIONS.count END AS IDLE_CONNECTIONS_COUNT, CASE WHEN BLOCKED_TRANSACTIONS.count IS NULL THEN 0 ELSE BLOCKED_TRANSACTIONS.count END AS BLOCKED_TRANSACTIONS_COUNT, CASE WHEN EXPENSIVE_STATEMENTS.count IS NULL THEN 0 ELSE EXPENSIVE_STATEMENTS.count END AS EXPENSIVE_STATEMENTS_COUNT, EXPENSIVE_STATEMENTS.total_duration_microsec AS EXPENSIVE_STATEMENTS_DURATION, CASE WHEN RECORD_LOCKS.count IS NULL THEN 0 ELSE RECORD_LOCKS.count END AS RECORD_LOCK_COUNT, CASE WHEN GROUPED_CACHES.count IS NULL THEN 0 ELSE GROUPED_CACHES.count END AS CACHE_COUNT, GROUPED_CACHES.total_size AS CACHE_CAPACITY, GROUPED_CACHES.used_size AS CACHE_USED_SIZE, CASE WHEN GROUPED_CACHES.entry_count IS NULL THEN 0 ELSE GROUPED_CACHES.entry_count END AS CACHE_ENTRY_COUNT, CASE WHEN GROUPED_CACHES.insert_count IS NULL THEN 0 ELSE GROUPED_CACHES.insert_count END AS CACHE_INSERT_COUNT, CASE WHEN GROUPED_CACHES.invalidate_count IS NULL THEN 0 ELSE GROUPED_CACHES.invalidate_count END AS CACHE_INVALIDATE_COUNT, CASE WHEN GROUPED_CACHES.hit_count IS NULL THEN 0 ELSE GROUPED_CACHES.hit_count END AS CACHE_HIT_COUNT, CASE WHEN GROUPED_CACHES.miss_count IS NULL THEN 0 ELSE GROUPED_CACHES.miss_count END AS CACHE_MISS_COUNT, CASE WHEN TRANSACTIONS.count IS NULL THEN 0 ELSE TRANSACTIONS.count END AS ALL_TIME_TRANSACTION_COUNT, CASE WHEN CURRENT_TRANSACTIONS.count IS NULL THEN 0 ELSE CURRENT_TRANSACTIONS.count END AS CURRENT_TRANSACTION_COUNT, CASE WHEN CURRENT_TRANSACTIONS.inactive_count IS NULL THEN 0 ELSE CURRENT_TRANSACTIONS.inactive_count END AS INACTIVE_TRANSACTION_COUNT, CASE WHEN CURRENT_TRANSACTIONS.active_count IS NULL THEN 0 ELSE CURRENT_TRANSACTIONS.active_count END AS ACTIVE_TRANSACTION_COUNT, CASE WHEN CURRENT_TRANSACTIONS.precommitted_count IS NULL THEN 0 ELSE CURRENT_TRANSACTIONS.precommitted_count END AS PRECOMMITTED_TRANSACTION_COUNT, CASE WHEN CURRENT_TRANSACTIONS.aborting_count IS NULL THEN 0 ELSE CURRENT_TRANSACTIONS.aborting_count END AS ABORTING_TRANSACTION_COUNT, CASE WHEN CURRENT_TRANSACTIONS.partial_aborting_count IS NULL THEN 0 ELSE CURRENT_TRANSACTIONS.partial_aborting_count END AS PARTIAL_ABORTING_TRANSACTION_COUNT, CASE WHEN CURRENT_TRANSACTIONS.active_prepare_commit_count IS NULL THEN 0 ELSE CURRENT_TRANSACTIONS.active_prepare_commit_count END AS ACTIVE_PREPARE_COMMIT_TRANSACTION_COUNT, CASE WHEN CURRENT_TRANSACTIONS.user_count IS NULL THEN 0 ELSE CURRENT_TRANSACTIONS.user_count END AS USER_TRANSACTION_COUNT, CASE WHEN CURRENT_TRANSACTIONS.version_garbage_collection_count IS NULL THEN 0 ELSE CURRENT_TRANSACTIONS.version_garbage_collection_count END AS VERSION_GARBAGE_COLLECTION_TRANSACTION_COUNT, CASE WHEN CURRENT_TRANSACTIONS.ddl_version_garbage_collection_count IS NULL THEN 0 ELSE CURRENT_TRANSACTIONS.ddl_version_garbage_collection_count END AS DDL_VERSION_GARBAGE_COLLECTION_TRANSACTION_COUNT, CASE WHEN CURRENT_TRANSACTIONS.internal_count IS NULL THEN 0 ELSE CURRENT_TRANSACTIONS.internal_count END AS INTERNAL_TRANSACTION_COUNT, CASE WHEN CURRENT_TRANSACTIONS.external_count IS NULL THEN 0 ELSE CURRENT_TRANSACTIONS.external_count END AS EXTERNAL_TRANSACTION_COUNT, CURRENT_TRANSACTIONS.avg_run_time_seconds AS AVG_CURRENT_TRANSACTION_RUN_TIME_SECONDS, CURRENT_TRANSACTIONS.max_run_time_seconds AS MAX_CURRENT_TRANSACTION_RUN_TIME_SECONDS, CASE WHEN JOBS.count IS NULL THEN 0 ELSE JOBS.count END AS JOB_COUNT, SERVICE_STATISTICS.max_start_time AS MAX_SERVICE_START_TIME, Nano100_between(SERVICE_STATISTICS.max_start_time, CURRENT_TIMESTAMP) / 36000000000 AS UPTIME FROM sys.m_landscape_host_configuration LEFT OUTER JOIN sys.m_host_resource_utilization ON m_landscape_host_configuration.host = m_host_resource_utilization.host LEFT OUTER JOIN m_host_information IP_ADDRESS ON m_host_resource_utilization.host = IP_ADDRESS.host AND IP_ADDRESS.KEY = 'net_ip_addresses' LEFT OUTER JOIN (SELECT host, Max(start_time) AS MAX_START_TIME FROM m_service_statistics GROUP BY host) SERVICE_STATISTICS ON m_landscape_host_configuration.host = SERVICE_STATISTICS.host LEFT OUTER JOIN (SELECT host, Sum(physical_memory_size) AS PHYSICAL_MEMORY_SIZE, Sum(shared_memory_allocated_size) AS SHARED_MEMORY_ALLOCATED_SIZE FROM sys.m_service_memory GROUP BY m_service_memory.host) GROUPED_SERVICE_MEMORY ON m_landscape_host_configuration.host = GROUPED_SERVICE_MEMORY.host LEFT OUTER JOIN (SELECT host, Sum(process_cpu_time) AS PROCESS_CPU_TIME FROM m_service_statistics GROUP BY host) GROUPED_SERVICE_STATISTICS ON m_landscape_host_configuration.host = GROUPED_SERVICE_STATISTICS.host LEFT OUTER JOIN (SELECT host, Count(*) AS COUNT FROM m_service_threads WHERE is_active = 'TRUE' GROUP BY host) ACTIVE_THREADS ON m_landscape_host_configuration.host = ACTIVE_THREADS.host LEFT OUTER JOIN (SELECT host, Count(*) AS COUNT FROM m_service_threads WHERE is_active = 'FALSE' GROUP BY host) INACTIVE_THREADS ON m_landscape_host_configuration.host = INACTIVE_THREADS.host LEFT OUTER JOIN (SELECT host, Count(*) AS COUNT FROM m_connections WHERE connection_status = 'RUNNING' GROUP BY host) RUNNING_CONNECTIONS ON m_landscape_host_configuration.host = RUNNING_CONNECTIONS.host LEFT OUTER JOIN (SELECT host, Count(*) AS COUNT FROM m_connections WHERE connection_status = 'IDLE' GROUP BY host) IDLE_CONNECTIONS ON m_landscape_host_configuration.host = IDLE_CONNECTIONS.host LEFT OUTER JOIN (SELECT host, Count(*) AS COUNT FROM m_blocked_transactions GROUP BY host) BLOCKED_TRANSACTIONS ON m_landscape_host_configuration.host = BLOCKED_TRANSACTIONS.host LEFT OUTER JOIN (SELECT host, Count(*) AS COUNT, Sum(duration_microsec) AS TOTAL_DURATION_MICROSEC FROM m_expensive_statements GROUP BY host) EXPENSIVE_STATEMENTS ON m_landscape_host_configuration.host = EXPENSIVE_STATEMENTS.host LEFT OUTER JOIN (SELECT host, Count(*) AS COUNT FROM m_record_locks GROUP BY host) RECORD_LOCKS ON m_landscape_host_configuration.host = RECORD_LOCKS.host LEFT OUTER JOIN (SELECT host, Count(*) AS COUNT FROM sys.m_transactions GROUP BY host) TRANSACTIONS ON m_landscape_host_configuration.host = TRANSACTIONS.host LEFT OUTER JOIN (SELECT host, Count(*) AS COUNT FROM sys.m_job_progress GROUP BY host) JOBS ON m_landscape_host_configuration.host = JOBS.host LEFT OUTER JOIN (SELECT host, Count(*) AS COUNT, Sum(CASE WHEN transaction_status = 'INACTIVE' THEN 1 ELSE 0 END) AS INACTIVE_COUNT, Sum(CASE WHEN transaction_status = 'ACTIVE' THEN 1 ELSE 0 END) AS ACTIVE_COUNT, Sum(CASE WHEN transaction_status = 'PRECOMMITTED' THEN 1 ELSE 0 END) AS PRECOMMITTED_COUNT, Sum(CASE WHEN transaction_status = 'ABORTING' THEN 1 ELSE 0 END) AS ABORTING_COUNT, Sum(CASE WHEN transaction_status = 'PARTIAL_ABORTING' THEN 1 ELSE 0 END) AS PARTIAL_ABORTING_COUNT, Sum(CASE WHEN transaction_status = 'ACTIVE_PREPARE_COMMIT' THEN 1 ELSE 0 END) AS ACTIVE_PREPARE_COMMIT_COUNT, Sum(CASE WHEN transaction_type = 'USER' THEN 1 ELSE 0 END) AS USER_COUNT, Sum(CASE WHEN transaction_type = 'VERSION GARBAGE COLLECTION' THEN 1 ELSE 0 END) AS VERSION_GARBAGE_COLLECTION_COUNT, Sum(CASE WHEN transaction_type = 'DDL VERSION GARBAGE COLLECTION' THEN 1 ELSE 0 END) AS DDL_VERSION_GARBAGE_COLLECTION_COUNT, Sum(CASE WHEN transaction_type = 'INTERNAL' THEN 1 ELSE 0 END) AS INTERNAL_COUNT, Sum(CASE WHEN transaction_type = 'EXTERNAL' THEN 1 ELSE 0 END) AS EXTERNAL_COUNT, Avg(Seconds_between(Now(), start_time)) AS AVG_RUN_TIME_SECONDS, Min(Seconds_between(Now(), start_time)) AS MAX_RUN_TIME_SECONDS FROM sys.m_transactions WHERE end_time IS NULL GROUP BY host) CURRENT_TRANSACTIONS ON m_landscape_host_configuration.host = CURRENT_TRANSACTIONS.host LEFT OUTER JOIN (SELECT m_caches.host, Count(*) AS COUNT, Sum(total_size_fixed) AS TOTAL_SIZE, Sum(used_size) AS USED_SIZE, Sum(entry_count) AS ENTRY_COUNT, Sum(insert_count) AS INSERT_COUNT, Sum(invalidate_count) AS INVALIDATE_COUNT, Sum(hit_count) AS HIT_COUNT, Sum(miss_count) AS MISS_COUNT FROM m_caches LEFT OUTER JOIN (SELECT host, Sum(total_size) AS TOTAL_SIZE_FIXED FROM m_caches WHERE total_size >= 0 GROUP BY m_caches.host) TS ON TS.host = m_caches.host GROUP BY m_caches.host) GROUPED_CACHES ON m_landscape_host_configuration.host = GROUPED_CACHES.host

      - name: system_info_alerts
        run: SELECT alert_id, alert_name, alert_description, alert_details AS ALERT_MESSAGE, alert_useraction AS RECOMMENDATION FROM _sys_statistics.statistics_current_alerts WHERE alert_rating = 1

      - name: system_warning_alerts
        run: SELECT ALERT_ID ,ALERT_NAME ,ALERT_DESCRIPTION ,ALERT_DETAILS AS ALERT_MESSAGE ,ALERT_USERACTION AS RECOMMENDATION FROM _SYS_STATISTICS.STATISTICS_CURRENT_ALERTS WHERE ALERT_RATING = 2

      - name: system_serious_alerts
        run: SELECT ALERT_ID ,ALERT_NAME ,ALERT_DESCRIPTION ,ALERT_DETAILS AS ALERT_MESSAGE ,ALERT_USERACTION AS RECOMMENDATION FROM _SYS_STATISTICS.STATISTICS_CURRENT_ALERTS WHERE ALERT_RATING = 3

      - name: system_critical_alerts
        run: SELECT ALERT_ID ,ALERT_NAME ,ALERT_DESCRIPTION ,ALERT_DETAILS AS ALERT_MESSAGE ,ALERT_USERACTION AS RECOMMENDATION FROM _SYS_STATISTICS.STATISTICS_CURRENT_ALERTS WHERE ALERT_RATING = 4

      - name: system_fatal_alerts
        run: SELECT ALERT_ID ,ALERT_NAME ,ALERT_DESCRIPTION ,ALERT_DETAILS AS ALERT_MESSAGE ,ALERT_USERACTION AS RECOMMENDATION FROM _SYS_STATISTICS.STATISTICS_CURRENT_ALERTS WHERE ALERT_RATING = 5

      - name: system_status_collect
        run: SELECT * FROM sys.m_system_overview

      - name: system_host_info_collect
        run: SELECT * FROM sys.m_host_information

      - name: system_host_count_collect
        run: SELECT Count(DISTINCT host) AS TOTAL_HOSTS FROM sys.m_host_information

      - name: system_host_running_collect
        run: SELECT Count(DISTINCT host) AS RUNNING_HOSTS FROM sys.m_host_information WHERE KEY = 'active' AND value = 'yes'

      - name: system_host_utilization_collect
        run: SELECT Sum(total_cpu_user_time) AS USER_TIME, Sum(total_cpu_system_time) AS SYSTEM_TIME, Sum(total_cpu_wio_time) AS WIO_TIME, Sum(total_cpu_idle_time) AS IDLE_TIME, Sum(used_physical_memory) AS PHYSICAL_MEMORY_USED, Sum(used_physical_memory) + Sum(free_physical_memory) AS PHYSICAL_MEMORY_TOTAL, Sum(used_physical_memory) / ( Sum(used_physical_memory) + Sum(free_physical_memory) ) * 100 AS PHYSICAL_MEMORY_UTILIZATION, Sum(used_physical_memory) + Sum(used_swap_space) AS VIRTUAL_MEMORY_USED, Sum(used_physical_memory) + Sum(free_physical_memory) + Sum(used_swap_space) + Sum(free_swap_space) AS TOTAL_VIRTUAL_MEMORY, ( Sum(used_physical_memory) + Sum(used_swap_space) ) / ( Sum(used_physical_memory) + Sum(free_physical_memory) + Sum(used_swap_space) + Sum(free_swap_space) ) * 100 AS VIRUTAL_MEMORY_UTILIZATION FROM sys.m_host_resource_utilization

      - name: system_host_disk_collect
        run: SELECT * FROM SYS.M_DISKS

      - name: system_service_statistics_collect
        run: SELECT sum(REQUESTS_PER_SEC) AS REQUEST_RATE ,sum(REQUESTS_PER_SEC * RESPONSE_TIME) / sum(REQUESTS_PER_SEC) AS AVERAGE_RESPONSE_TIME FROM SYS.M_SERVICE_STATISTICS WHERE REQUESTS_PER_SEC >= 0

      - name: system_connections_running_collect
        run: SELECT COUNT(*) AS RUNNING_CONNECTIONS FROM M_CONNECTIONS WHERE CONNECTION_STATUS = 'RUNNING'

      - name: system_connections_idle_collect
        run: SELECT COUNT(*) AS IDLE_CONNECTIONS FROM M_CONNECTIONS WHERE CONNECTION_STATUS = 'IDLE'

      - name: system_jobs_count_collect
        run: SELECT COUNT(*) AS JOB_COUNT FROM SYS.M_JOB_PROGRESS

      - name: system_statements_count_collect
        run: SELECT COUNT(*) AS EXPENSIVE_STATEMENTS_COUNT ,SUM(DURATION_MICROSEC) AS EXPENSIVE_STATEMENTS_DURATION FROM SYS.M_EXPENSIVE_STATEMENTS

      - name: system_blocked_transactions_count_collect
        run: SELECT COUNT(*) AS BLOCKED_TRANSACTIONS_COUNT FROM M_BLOCKED_TRANSACTIONS

      - name: system_global_allocation_limit
        run: SELECT DISTINCT VALUE AS GLOBAL_ALLOCATION_LIMIT FROM SYS.M_MEMORY WHERE NAME='GLOBAL_ALLOCATION_LIMIT'
